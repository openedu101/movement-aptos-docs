# Type Arguments


## Calling Generic Function
- Khi gọi một function generic, bạn có thể chỉ định các type arguments cho các type parameters của function trong một danh sách được bao bởi một cặp dấu ngoặc nhọn.

```rust
fun foo() {
    let x = id<bool>(true);
}
```
- Nếu bạn không chỉ định các type arguments, Move's type inference sẽ cung cấp chúng cho bạn.

## Using Generic Structs
- Tương tự, bạn có thể đính kèm một danh sách các type arguments cho các type parameters của structs khi khởi tạo hoặc hủy bỏ các giá trị của các generic types.

```rust
fun foo() {
    let foo = Foo<bool> { x: true };
    let Foo<bool> { x } = foo;
}
```

## Type Argument Mismatch
- Nếu bạn chỉ định các đối số kiểu và chúng không khớp với các giá trị thực tế được cung cấp, sẽ xảy ra lỗi:
```rust
fun foo() {
    let x = id<u64>(true); // error! true is not a u64
}
```

```rust
fun foo() {
    let foo = Foo<bool> { x: 0 }; // error! 0 is not a bool
    let Foo<address> { x } = foo; // error! bool is incompatible with address
}
```

# Unused Type Parameters
- Đối với định nghĩa structs, một type parameter không sử dụng là tham số không xuất hiện trong bất kỳ trường nào được định nghĩa trong struct, nhưng vẫn được kiểm tra tĩnh tại thời điểm biên dịch. Move cho phép các tham số kiểu không sử dụng, vì vậy định nghĩa cấu trúc sau là hợp lệ:

```rust
struct Foo<T> {
    foo: u64
}
```

- Điều này có thể tiện lợi khi mô hình hóa (modeling) các khái niệm nhất định. Dưới đây là một ví dụ:
```rust
module my_addrx::M{
    // Currency Specifiers
    struct Currency1 {}
    struct Currency2 {}

    // A generic coin type that can be instantiated using a currency
    // specifier type.
    //   e.g. Coin<Currency1>, Coin<Currency2> etc.
    struct Coin<Currency> has store {
        value: u64
    }

    // Write code generically about all currencies
    public fun mint_generic<Currency>(value: u64): Coin<Currency> {
        Coin { value }
    }

    // Write code concretely about one currency
    public fun mint_concrete(value: u64): Coin<Currency1> {
        Coin { value }
    }
}
```

- Trong ví dụ này, cấu trúc `Coin<Currency>` là generic với tham số kiểu `Currency`, điều này chỉ định loại tiền tệ của đồng tiền và cho phép mã được viết theo kiểu tổng quát cho bất kỳ loại tiền tệ nào hoặc cụ thể cho một loại tiền tệ nhất định. Tính tổng quát này vẫn áp dụng ngay cả khi tham số kiểu Currency không xuất hiện trong bất kỳ trường nào được định nghĩa trong Coin.
